"""Reusable docs payloads for the external integration API."""

from __future__ import annotations

import json
from typing import Any

from app.config import settings

INTEGRATION_DOCS_TAG_DESCRIPTION = """
Public documentation endpoints for external Donkey SEO clients.
"""

INTEGRATION_ARTICLES_TAG_DESCRIPTION = """
API-key protected content endpoints intended for machine-to-machine integrations.
"""

MODULAR_DOCUMENT_CONTRACT: dict[str, Any] = {
    "schema_version": "1.0",
    "seo_meta": {
        "h1": "Primary on-page headline",
        "meta_title": "Browser title / SERP title",
        "meta_description": "SERP meta description",
        "slug": "url-safe-slug",
        "primary_keyword": "primary keyword phrase",
    },
    "conversion_plan": {
        "primary_intent": "informational|commercial|transactional|navigational or custom value",
        "cta_strategy": [
            "Narrative CTA plan notes generated by Donkey SEO",
        ],
    },
    "featured_image": {
        "object_key": "projects/<project_id>/content-images/<brief_id>/<sha256>.png",
        "mime_type": "image/png",
        "width": 1200,
        "height": 630,
        "byte_size": 185422,
        "sha256": "<sha256>",
        "title_text": "Canonical image title text",
        "template_version": "1.0",
        "source": "llm_template_spec",
        "style_variant_id": "variant-hero-balance",
        "signed_url": "https://... (optional, short-lived, present on delivery/read payloads)",
    },
    "blocks": [
        {
            "block_type": (
                "hero|summary|section|list|comparison_table|steps|faq|cta|conclusion|sources"
            ),
            "semantic_tag": "header|section|aside|footer|table",
            "heading": "Optional heading text",
            "level": 2,
            "body": "Optional paragraph body",
            "items": ["List or steps items"],
            "ordered": False,
            "table_columns": ["Column A", "Column B"],
            "table_rows": [["cell 1", "cell 2"]],
            "faq_items": [{"question": "Q", "answer": "A"}],
            "cta": {"label": "Learn more", "href": "https://example.com"},
            "links": [{"anchor": "Anchor text", "href": "https://example.com/resource"}],
        }
    ],
}

MODULAR_DOCUMENT_CONTRACT_JSON = json.dumps(
    MODULAR_DOCUMENT_CONTRACT,
    indent=2,
    sort_keys=True,
)

INTEGRATION_API_DESCRIPTION = """
Donkey SEO integration API for external programs.

This API is split into:
- public docs/guide routes (no authentication)
- API-key protected content routes for machine-to-machine article retrieval and publication callbacks
"""

INTEGRATION_PUBLIC_BASE_PATH = settings.versioned_integration_api_prefix

DONKEY_CLIENT_GUIDE_MARKDOWN = """
# Donkey SEO Client Implementation Guide (For Coding Agents)

This guide is for the engineer/coding agent implementing a Donkey SEO client.
Your job is to ingest article versions from Donkey SEO and transform them into
SEO-ready blog entities in your own repository and CRM with zero data loss.

## 1) Authentication Model

- Use `X-API-Key` on protected integration routes.
- Use a project-scoped API key generated from `/api/v1/projects/{project_id}/api-key`.
- Do not send JWT bearer tokens to integration routes.
- Keep API keys in secret storage and rotate them regularly.

## 2) Endpoints To Implement

- `GET __INTEGRATION_BASE_PATH__/article/{article_id}?project_id={project_id}`
  - Returns latest immutable version for that article.
- `GET __INTEGRATION_BASE_PATH__/article/{article_id}/versions/{version_number}?project_id={project_id}`
  - Returns explicit immutable version.
- `PATCH __INTEGRATION_BASE_PATH__/article/{article_id}/publication?project_id={project_id}`
  - Receives publication status updates from your CMS/blog integration.
- Response source of truth is `content_article_versions`.

Publication callback payload fields:
- `publish_status` (`scheduled|published|failed`)
- `published_at` (ISO datetime, required when `publish_status=published`)
- `published_url` (URL, required when `publish_status=published`)

## 3) Fields You Must Persist (Non-Optional For Integrators)

- `article_id`
- `project_id`
- `version_number`
- `title`
- `slug`
- `primary_keyword`
- `status`
- `modular_document` (store RAW JSON unchanged)
- `rendered_html` (fallback rendering / compare output / debugging)
- `qa_report`
- `change_reason`
- `generation_model`
- `generation_temperature`
- `created_by_regeneration`
- `created_at`
- `updated_at`

Storage rules:
1. Use `(article_id, version_number)` as immutable key.
2. Never overwrite old versions.
3. Store raw payload before any transform.

## 4) Canonical `modular_document` Contract

Top-level:
- `schema_version`
- `seo_meta`
- `conversion_plan`
- `featured_image` (optional)
- `blocks`

`seo_meta`:
- `h1`
- `meta_title`
- `meta_description`
- `slug`
- `primary_keyword`

`conversion_plan`:
- `primary_intent`
- `cta_strategy` (array of strategy notes)

`featured_image` (optional):
- `object_key`
- `mime_type`
- `width`
- `height`
- `byte_size`
- `sha256`
- `title_text`
- `template_version`
- `source`
- `style_variant_id`
- `signed_url` (short-lived; may be included in delivery/read payloads only)

Each `blocks[]` item can contain:
- `block_type`
- `semantic_tag`
- `heading`
- `level`
- `body`
- `items`
- `ordered`
- `table_columns`
- `table_rows`
- `faq_items`
- `cta`
- `links`

## 5) Critical Parsing Requirements (Must Implement)

1. Parse by `block_type`, never by positional assumptions.
2. Preserve exact block order from input.
3. Handle optional/null fields safely with explicit defaults.
4. Preserve nested shapes:
   - `faq_items[]`
   - `cta`
   - `table_columns` + `table_rows`
   - `links[]`
   - `featured_image` metadata
5. Keep transform pipeline auditable:
   - raw payload
   - normalized internal model
   - CRM/CMS publish payload
6. Unsupported block types must not be dropped silently:
   - log warning
   - keep raw block in extension data
7. Parser must be schema-version aware (`schema_version`).
8. Do not persist `featured_image.signed_url`; treat it as ephemeral fetch URL.
9. Add block-level tests for all supported `block_type` values.

## 6) SEO-First Parsing Playbook (Very Important)

Treat `modular_document` as the structured SEO source, not just content text.

`seo_meta` handling:
1. `h1`:
   - Use as canonical page H1.
   - Ensure exactly one H1 in final rendered page.
2. `meta_title`:
   - Use directly unless your CMS enforces hard limits.
   - If truncation is required, preserve keyword intent and readability.
3. `meta_description`:
   - Preserve semantic intent; avoid rewriting unless style-guide requires it.
4. `slug`:
   - Prefer source slug; apply your own canonicalization only if required.
   - Keep mapping from source slug to published slug for traceability.
5. `primary_keyword`:
   - Persist as strategy metadata in CRM for reporting and QA.

`conversion_plan` handling:
1. `primary_intent` drives narrative tone and CTA aggressiveness.
2. `cta_strategy` must be persisted and passed to editorial/publishing layers.

## 7) Block-Type SEO Optimization Rules

Use these rules when mapping `blocks` to your CMS components.

- `hero`
  - Must contain the top-of-page headline section.
  - Ensure no extra H1 is introduced elsewhere.
  - Keep intro concise and intent-aligned.

- `summary`
  - Use as above-the-fold summary/snippet section.
  - Keep scannable; include semantic heading if provided.

- `section`
  - Map to standard body sections.
  - Respect `level` (H2-H4) in heading hierarchy.
  - Do not flatten all headings to same level.

- `list`
  - Render as `<ul>` or `<ol>` using `ordered`.
  - Preserve item order and wording.

- `steps`
  - Render as ordered process flow.
  - Preserve sequence exactly; sequence is meaning.

- `comparison_table`
  - Render semantic table with headers.
  - Keep all rows/columns; do not drop sparse rows silently.
  - Add table accessibility semantics per your frontend standard.

- `faq`
  - Persist each Q/A pair as structured items.
  - Also store as FAQ metadata for schema generation in your CMS.
  - Keep answer fidelity; avoid paraphrasing that changes intent.

- `cta`
  - Map `cta.label` and `cta.href` exactly.
  - Keep CTA location in block sequence unless your system has controlled CTA slots.
  - Respect `conversion_plan.cta_strategy`.

- `conclusion`
  - Keep as terminal recap/decision section.
  - Preserve closing CTA context if present.

- `sources`
  - Treat as citation/reference block.
  - Persist source links and anchor text for compliance/audit.

## 8) Link Parsing and SEO Link Graph Handling

For each block `links[]` item:
- Persist `anchor` and `href` exactly.
- Classify internal vs external by your domain rules.
- Preserve per-block link placement context for editorial auditing.

Recommended:
1. Track link index by block order.
2. Maintain outbound link logs for compliance and refresh workflows.
3. Create internal-link opportunities if your CMS supports related-content modules.

## 9) Publication Decision Tree (CMS vs No CMS)

Use this exact decision logic:

1. Detect whether the repository has a CMS publishing target.
2. If CMS exists:
   - Use a `CmsPublicationAdapter`.
   - Map normalized `modular_document` blocks to CMS-native components.
   - Publish/stage and persist CMS IDs + URLs.
3. If CMS does not exist:
   - Build an `ArticleViewerAdapter` (internal renderer).
   - Render `modular_document` semantically in your own app routes/templates.
   - Persist publish metadata as internal viewer URL + render checksum.
4. If neither path is immediately available:
   - Store article versions as `ready_to_publish`.
   - Do not discard the content; keep it queryable via internal API/DB.

Reference adapter interface:
- `publish(normalized_article) -> PublicationResult`
- `PublicationResult` should include `target_type` (`cms` or `viewer`), `target_id`,
  `target_url`, `version_number`, and `checksum`.

## 10) Deterministic Transform Pipeline

Implement this flow in your client:

1. `fetch_version()`
2. `persist_raw()`
3. `validate_contract()`
4. `normalize_document()`
5. `map_blocks_to_components()`
6. `apply_seo_meta()`
7. `publish_or_stage()`
8. `persist_publish_audit()`

Validation gates to fail fast:
- missing `modular_document`
- non-array `blocks`
- missing critical `seo_meta` primitives (`h1`, `slug`, `primary_keyword`)
- irrecoverable block payload type mismatch

## 11) Suggested Pseudocode

```text
payload = fetch_article_version(article_id, project_id, version_number?)
store_raw(payload)

doc = payload.modular_document
assert doc.schema_version is not null
assert is_array(doc.blocks)

internal = normalize(doc)
components = []
for block in internal.blocks_in_order:
    components.append(map_block(block))

page = assemble_page(
    seo_meta=internal.seo_meta,
    conversion_plan=internal.conversion_plan,
    components=components
)

publish(page)
store_publish_record(article_id, version_number, page_id, checksum)
```

## 12) QA And SEO Guardrails To Add In Your Client

Before publishing:
1. Exactly one H1 check.
2. Heading hierarchy sanity check (H2-H4 flow).
3. Slug and canonical URL check.
4. Meta title/description presence check.
5. CTA presence check for commercial/transactional intent.
6. FAQ block validity check if FAQ exists.
7. Broken link check on `links[]` and CTA hrefs.

## 13) CRM Storage Model Recommendation

- `article_versions` table/collection:
  - immutable raw data and normalized data
- `published_articles` table/collection:
  - mutable publication state, CMS IDs, live URL, rollout status
- `parse_events` table/collection:
  - parse warnings, unsupported blocks, validation outcomes

## 14) Forward Compatibility Rules

1. Parse with tolerant readers and strict writers.
2. Ignore unknown fields only after storing them.
3. Maintain parser version tags in your own records.
4. Add migration adapters when `schema_version` changes.

## 15) Non-Negotiable Rule

The client implementer must parse `modular_document` deeply, preserve structure,
and apply SEO-aware block mapping in a way that aligns with their repository style
guide and CRM architecture. `modular_document` is the primary artifact used to
create publishable blog content.

## 16) Publication Webhook Flow

Donkey SEO can call your configured project webhook at publication time with
event type `content.article.publish_requested`.

Outbound payload includes:
- `event_id` (stable across retries)
- `event_type`
- `occurred_at`
- `project` metadata (`id`, `domain`, `locale`)
- `article` metadata (`article_id`, `brief_id`, `version_number`, `title`, `slug`, `primary_keyword`, `proposed_publication_date`)
- `modular_document` (includes optional `featured_image` with short-lived `signed_url` when available)
- `rendered_html`

Outbound headers:
- `X-Donkey-Event`
- `X-Donkey-Delivery-Id`
- `X-Donkey-Timestamp`
- `X-Donkey-Signature`

Signature verification:
1. Build message: `"{X-Donkey-Timestamp}.{raw_request_body}"`.
2. Compute `HMAC SHA256` with your webhook secret.
3. Compare against `X-Donkey-Signature` (`sha256=<hex_digest>`).

Retry policy:
- Up to 5 attempts.
- Retries on network failures and non-2xx responses.
- Exponential backoff from 60 seconds.

Idempotency guidance:
- Use `event_id` as idempotency key in your receiver.
- Treat duplicate `event_id` deliveries as retries, not new publication jobs.

End-to-end sequence:
1. Donkey SEO sends publish-request webhook with latest immutable article version.
2. Your integration publishes to your CMS/blog.
3. Your integration PATCHes publication result back to Donkey SEO.
""".replace("__INTEGRATION_BASE_PATH__", INTEGRATION_PUBLIC_BASE_PATH)
