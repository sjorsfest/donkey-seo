"""Auto-generated dataclass DTOs from SQLAlchemy models.

Generated by: scripts/generate_model_dtos.py
Do not edit manually; regenerate instead.
"""

from __future__ import annotations

from dataclasses import asdict, dataclass, field
from datetime import date, datetime
from typing import Any, ClassVar


@dataclass(slots=True)
class BrandProfileRow:
    """Read DTO for `BrandProfile`."""

    project_id: str
    raw_content: str | None
    source_pages: list[str] | None
    products_services: list[dict] | None
    money_pages: list[dict] | None
    company_name: str | None
    tagline: str | None
    unique_value_props: list[str] | None
    differentiators: list[str] | None
    competitor_positioning: list[dict] | None
    target_roles: list[str] | None
    target_industries: list[str] | None
    company_sizes: list[str] | None
    primary_pains: list[str] | None
    desired_outcomes: list[str] | None
    objections: list[str] | None
    tone_attributes: list[str] | None
    allowed_claims: list[str] | None
    restricted_claims: list[str] | None
    in_scope_topics: list[str] | None
    out_of_scope_topics: list[str] | None
    extraction_model: str | None
    extraction_confidence: float | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "BrandProfileRow":
        return cls(
            project_id=model.project_id,
            raw_content=model.raw_content,
            source_pages=model.source_pages,
            products_services=model.products_services,
            money_pages=model.money_pages,
            company_name=model.company_name,
            tagline=model.tagline,
            unique_value_props=model.unique_value_props,
            differentiators=model.differentiators,
            competitor_positioning=model.competitor_positioning,
            target_roles=model.target_roles,
            target_industries=model.target_industries,
            company_sizes=model.company_sizes,
            primary_pains=model.primary_pains,
            desired_outcomes=model.desired_outcomes,
            objections=model.objections,
            tone_attributes=model.tone_attributes,
            allowed_claims=model.allowed_claims,
            restricted_claims=model.restricted_claims,
            in_scope_topics=model.in_scope_topics,
            out_of_scope_topics=model.out_of_scope_topics,
            extraction_model=model.extraction_model,
            extraction_confidence=model.extraction_confidence,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class BrandProfileCreateDTO:
    """Create DTO for `BrandProfile`."""

    project_id: str
    raw_content: str | None = None
    source_pages: list[str] | None = None
    products_services: list[dict] | None = None
    money_pages: list[dict] | None = None
    company_name: str | None = None
    tagline: str | None = None
    unique_value_props: list[str] | None = None
    differentiators: list[str] | None = None
    competitor_positioning: list[dict] | None = None
    target_roles: list[str] | None = None
    target_industries: list[str] | None = None
    company_sizes: list[str] | None = None
    primary_pains: list[str] | None = None
    desired_outcomes: list[str] | None = None
    objections: list[str] | None = None
    tone_attributes: list[str] | None = None
    allowed_claims: list[str] | None = None
    restricted_claims: list[str] | None = None
    in_scope_topics: list[str] | None = None
    out_of_scope_topics: list[str] | None = None
    extraction_model: str | None = None
    extraction_confidence: float | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class BrandProfilePatchDTO:
    """Sparse patch DTO for `BrandProfile`."""

    project_id: str | None = None
    raw_content: str | None = None
    source_pages: list[str] | None = None
    products_services: list[dict] | None = None
    money_pages: list[dict] | None = None
    company_name: str | None = None
    tagline: str | None = None
    unique_value_props: list[str] | None = None
    differentiators: list[str] | None = None
    competitor_positioning: list[dict] | None = None
    target_roles: list[str] | None = None
    target_industries: list[str] | None = None
    company_sizes: list[str] | None = None
    primary_pains: list[str] | None = None
    desired_outcomes: list[str] | None = None
    objections: list[str] | None = None
    tone_attributes: list[str] | None = None
    allowed_claims: list[str] | None = None
    restricted_claims: list[str] | None = None
    in_scope_topics: list[str] | None = None
    out_of_scope_topics: list[str] | None = None
    extraction_model: str | None = None
    extraction_confidence: float | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "BrandProfilePatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class BriefDeltaRow:
    """Read DTO for `BriefDelta`."""

    style_guide_id: str
    brief_id: str
    page_type_rules: dict | None
    must_include_sections: list[str] | None
    h1_h2_usage: dict | None
    internal_linking_minimums: dict | None
    schema_type: str | None
    schema_block_template: str | None
    link_placeholders: dict | None
    additional_qa_items: list[dict] | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "BriefDeltaRow":
        return cls(
            style_guide_id=model.style_guide_id,
            brief_id=model.brief_id,
            page_type_rules=model.page_type_rules,
            must_include_sections=model.must_include_sections,
            h1_h2_usage=model.h1_h2_usage,
            internal_linking_minimums=model.internal_linking_minimums,
            schema_type=model.schema_type,
            schema_block_template=model.schema_block_template,
            link_placeholders=model.link_placeholders,
            additional_qa_items=model.additional_qa_items,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class BriefDeltaCreateDTO:
    """Create DTO for `BriefDelta`."""

    style_guide_id: str
    brief_id: str
    page_type_rules: dict | None = None
    must_include_sections: list[str] | None = None
    h1_h2_usage: dict | None = None
    internal_linking_minimums: dict | None = None
    schema_type: str | None = None
    schema_block_template: str | None = None
    link_placeholders: dict | None = None
    additional_qa_items: list[dict] | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class BriefDeltaPatchDTO:
    """Sparse patch DTO for `BriefDelta`."""

    style_guide_id: str | None = None
    brief_id: str | None = None
    page_type_rules: dict | None = None
    must_include_sections: list[str] | None = None
    h1_h2_usage: dict | None = None
    internal_linking_minimums: dict | None = None
    schema_type: str | None = None
    schema_block_template: str | None = None
    link_placeholders: dict | None = None
    additional_qa_items: list[dict] | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "BriefDeltaPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class ContentArticleRow:
    """Read DTO for `ContentArticle`."""

    project_id: str
    brief_id: str
    title: str
    slug: str
    primary_keyword: str
    modular_document: dict
    rendered_html: str
    qa_report: dict | None
    status: str
    current_version: int
    generation_model: str | None
    generation_temperature: float | None
    generated_at: datetime
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "ContentArticleRow":
        return cls(
            project_id=model.project_id,
            brief_id=model.brief_id,
            title=model.title,
            slug=model.slug,
            primary_keyword=model.primary_keyword,
            modular_document=model.modular_document,
            rendered_html=model.rendered_html,
            qa_report=model.qa_report,
            status=model.status,
            current_version=model.current_version,
            generation_model=model.generation_model,
            generation_temperature=model.generation_temperature,
            generated_at=model.generated_at,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class ContentArticleCreateDTO:
    """Create DTO for `ContentArticle`."""

    project_id: str
    brief_id: str
    title: str
    slug: str
    primary_keyword: str
    modular_document: dict
    rendered_html: str
    qa_report: dict | None = None
    status: str | None = None
    current_version: int | None = None
    generation_model: str | None = None
    generation_temperature: float | None = None
    generated_at: datetime | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "status",
        "current_version",
        "generated_at",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class ContentArticlePatchDTO:
    """Sparse patch DTO for `ContentArticle`."""

    project_id: str | None = None
    brief_id: str | None = None
    title: str | None = None
    slug: str | None = None
    primary_keyword: str | None = None
    modular_document: dict | None = None
    rendered_html: str | None = None
    qa_report: dict | None = None
    status: str | None = None
    current_version: int | None = None
    generation_model: str | None = None
    generation_temperature: float | None = None
    generated_at: datetime | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "ContentArticlePatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class ContentArticleVersionRow:
    """Read DTO for `ContentArticleVersion`."""

    article_id: str
    version_number: int
    title: str
    slug: str
    primary_keyword: str
    modular_document: dict
    rendered_html: str
    qa_report: dict | None
    status: str
    change_reason: str | None
    generation_model: str | None
    generation_temperature: float | None
    created_by_regeneration: bool
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "ContentArticleVersionRow":
        return cls(
            article_id=model.article_id,
            version_number=model.version_number,
            title=model.title,
            slug=model.slug,
            primary_keyword=model.primary_keyword,
            modular_document=model.modular_document,
            rendered_html=model.rendered_html,
            qa_report=model.qa_report,
            status=model.status,
            change_reason=model.change_reason,
            generation_model=model.generation_model,
            generation_temperature=model.generation_temperature,
            created_by_regeneration=model.created_by_regeneration,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class ContentArticleVersionCreateDTO:
    """Create DTO for `ContentArticleVersion`."""

    article_id: str
    version_number: int
    title: str
    slug: str
    primary_keyword: str
    modular_document: dict
    rendered_html: str
    status: str
    qa_report: dict | None = None
    change_reason: str | None = None
    generation_model: str | None = None
    generation_temperature: float | None = None
    created_by_regeneration: bool | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "created_by_regeneration",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class ContentArticleVersionPatchDTO:
    """Sparse patch DTO for `ContentArticleVersion`."""

    article_id: str | None = None
    version_number: int | None = None
    title: str | None = None
    slug: str | None = None
    primary_keyword: str | None = None
    modular_document: dict | None = None
    rendered_html: str | None = None
    qa_report: dict | None = None
    status: str | None = None
    change_reason: str | None = None
    generation_model: str | None = None
    generation_temperature: float | None = None
    created_by_regeneration: bool | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "ContentArticleVersionPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class ContentBriefRow:
    """Read DTO for `ContentBrief`."""

    project_id: str
    topic_id: str
    target_keyword_id: str | None
    primary_keyword: str
    search_intent: str | None
    page_type: str | None
    funnel_stage: str | None
    working_titles: list[str] | None
    target_audience: str | None
    reader_job_to_be_done: str | None
    proposed_publication_date: date | None
    outline: list[dict] | None
    supporting_keywords: list[str] | None
    supporting_keywords_map: dict | None
    examples_required: list[str] | None
    faq_questions: list[str] | None
    recommended_schema_type: str | None
    internal_links_out: list[dict] | None
    internal_links_in: list[dict] | None
    money_page_links: list[dict] | None
    external_sources_required: list[str] | None
    meta_title_guidelines: str | None
    meta_description_guidelines: str | None
    target_word_count_min: int | None
    target_word_count_max: int | None
    must_include_sections: list[str] | None
    status: str
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "ContentBriefRow":
        return cls(
            project_id=model.project_id,
            topic_id=model.topic_id,
            target_keyword_id=model.target_keyword_id,
            primary_keyword=model.primary_keyword,
            search_intent=model.search_intent,
            page_type=model.page_type,
            funnel_stage=model.funnel_stage,
            working_titles=model.working_titles,
            target_audience=model.target_audience,
            reader_job_to_be_done=model.reader_job_to_be_done,
            proposed_publication_date=model.proposed_publication_date,
            outline=model.outline,
            supporting_keywords=model.supporting_keywords,
            supporting_keywords_map=model.supporting_keywords_map,
            examples_required=model.examples_required,
            faq_questions=model.faq_questions,
            recommended_schema_type=model.recommended_schema_type,
            internal_links_out=model.internal_links_out,
            internal_links_in=model.internal_links_in,
            money_page_links=model.money_page_links,
            external_sources_required=model.external_sources_required,
            meta_title_guidelines=model.meta_title_guidelines,
            meta_description_guidelines=model.meta_description_guidelines,
            target_word_count_min=model.target_word_count_min,
            target_word_count_max=model.target_word_count_max,
            must_include_sections=model.must_include_sections,
            status=model.status,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class ContentBriefCreateDTO:
    """Create DTO for `ContentBrief`."""

    project_id: str
    topic_id: str
    primary_keyword: str
    target_keyword_id: str | None = None
    search_intent: str | None = None
    page_type: str | None = None
    funnel_stage: str | None = None
    working_titles: list[str] | None = None
    target_audience: str | None = None
    reader_job_to_be_done: str | None = None
    proposed_publication_date: date | None = None
    outline: list[dict] | None = None
    supporting_keywords: list[str] | None = None
    supporting_keywords_map: dict | None = None
    examples_required: list[str] | None = None
    faq_questions: list[str] | None = None
    recommended_schema_type: str | None = None
    internal_links_out: list[dict] | None = None
    internal_links_in: list[dict] | None = None
    money_page_links: list[dict] | None = None
    external_sources_required: list[str] | None = None
    meta_title_guidelines: str | None = None
    meta_description_guidelines: str | None = None
    target_word_count_min: int | None = None
    target_word_count_max: int | None = None
    must_include_sections: list[str] | None = None
    status: str | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "status",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class ContentBriefPatchDTO:
    """Sparse patch DTO for `ContentBrief`."""

    project_id: str | None = None
    topic_id: str | None = None
    target_keyword_id: str | None = None
    primary_keyword: str | None = None
    search_intent: str | None = None
    page_type: str | None = None
    funnel_stage: str | None = None
    working_titles: list[str] | None = None
    target_audience: str | None = None
    reader_job_to_be_done: str | None = None
    proposed_publication_date: date | None = None
    outline: list[dict] | None = None
    supporting_keywords: list[str] | None = None
    supporting_keywords_map: dict | None = None
    examples_required: list[str] | None = None
    faq_questions: list[str] | None = None
    recommended_schema_type: str | None = None
    internal_links_out: list[dict] | None = None
    internal_links_in: list[dict] | None = None
    money_page_links: list[dict] | None = None
    external_sources_required: list[str] | None = None
    meta_title_guidelines: str | None = None
    meta_description_guidelines: str | None = None
    target_word_count_min: int | None = None
    target_word_count_max: int | None = None
    must_include_sections: list[str] | None = None
    status: str | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "ContentBriefPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class DiscoveryTopicSnapshotRow:
    """Read DTO for `DiscoveryTopicSnapshot`."""

    project_id: str
    pipeline_run_id: str
    iteration_index: int
    source_topic_id: str | None
    topic_name: str
    fit_tier: str | None
    fit_score: float | None
    keyword_difficulty: float | None
    domain_diversity: float | None
    validated_intent: str | None
    validated_page_type: str | None
    top_domains: list[str] | None
    decision: str
    rejection_reasons: list[str] | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "DiscoveryTopicSnapshotRow":
        return cls(
            project_id=model.project_id,
            pipeline_run_id=model.pipeline_run_id,
            iteration_index=model.iteration_index,
            source_topic_id=model.source_topic_id,
            topic_name=model.topic_name,
            fit_tier=model.fit_tier,
            fit_score=model.fit_score,
            keyword_difficulty=model.keyword_difficulty,
            domain_diversity=model.domain_diversity,
            validated_intent=model.validated_intent,
            validated_page_type=model.validated_page_type,
            top_domains=model.top_domains,
            decision=model.decision,
            rejection_reasons=model.rejection_reasons,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class DiscoveryTopicSnapshotCreateDTO:
    """Create DTO for `DiscoveryTopicSnapshot`."""

    project_id: str
    pipeline_run_id: str
    iteration_index: int
    topic_name: str
    decision: str
    source_topic_id: str | None = None
    fit_tier: str | None = None
    fit_score: float | None = None
    keyword_difficulty: float | None = None
    domain_diversity: float | None = None
    validated_intent: str | None = None
    validated_page_type: str | None = None
    top_domains: list[str] | None = None
    rejection_reasons: list[str] | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class DiscoveryTopicSnapshotPatchDTO:
    """Sparse patch DTO for `DiscoveryTopicSnapshot`."""

    project_id: str | None = None
    pipeline_run_id: str | None = None
    iteration_index: int | None = None
    source_topic_id: str | None = None
    topic_name: str | None = None
    fit_tier: str | None = None
    fit_score: float | None = None
    keyword_difficulty: float | None = None
    domain_diversity: float | None = None
    validated_intent: str | None = None
    validated_page_type: str | None = None
    top_domains: list[str] | None = None
    decision: str | None = None
    rejection_reasons: list[str] | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "DiscoveryTopicSnapshotPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class KeywordRow:
    """Read DTO for `Keyword`."""

    project_id: str
    seed_topic_id: str | None
    topic_id: str | None
    parent_keyword_id: str | None
    keyword: str
    keyword_normalized: str
    language: str
    locale: str
    source: str
    source_method: str | None
    raw_variants: list[str] | None
    exclusion_flags: list[str] | None
    search_volume: int | None
    search_volume_period: str | None
    cpc: float | None
    competition: float | None
    difficulty: float | None
    trend_data: list[int] | None
    metrics_data_source: str | None
    metrics_updated_at: datetime | None
    metrics_confidence: float | None
    intent: str | None
    intent_confidence: float | None
    recommended_page_type: str | None
    page_type_rationale: str | None
    funnel_stage: str | None
    risk_flags: list[str] | None
    priority_score: float | None
    priority_factors: dict | None
    serp_top_results: list[dict] | None
    serp_features: list[str] | None
    validated_intent: str | None
    validated_page_type: str | None
    format_requirements: list[str] | None
    serp_mismatch_flags: list[str] | None
    status: str
    exclusion_reason: str | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "KeywordRow":
        return cls(
            project_id=model.project_id,
            seed_topic_id=model.seed_topic_id,
            topic_id=model.topic_id,
            parent_keyword_id=model.parent_keyword_id,
            keyword=model.keyword,
            keyword_normalized=model.keyword_normalized,
            language=model.language,
            locale=model.locale,
            source=model.source,
            source_method=model.source_method,
            raw_variants=model.raw_variants,
            exclusion_flags=model.exclusion_flags,
            search_volume=model.search_volume,
            search_volume_period=model.search_volume_period,
            cpc=model.cpc,
            competition=model.competition,
            difficulty=model.difficulty,
            trend_data=model.trend_data,
            metrics_data_source=model.metrics_data_source,
            metrics_updated_at=model.metrics_updated_at,
            metrics_confidence=model.metrics_confidence,
            intent=model.intent,
            intent_confidence=model.intent_confidence,
            recommended_page_type=model.recommended_page_type,
            page_type_rationale=model.page_type_rationale,
            funnel_stage=model.funnel_stage,
            risk_flags=model.risk_flags,
            priority_score=model.priority_score,
            priority_factors=model.priority_factors,
            serp_top_results=model.serp_top_results,
            serp_features=model.serp_features,
            validated_intent=model.validated_intent,
            validated_page_type=model.validated_page_type,
            format_requirements=model.format_requirements,
            serp_mismatch_flags=model.serp_mismatch_flags,
            status=model.status,
            exclusion_reason=model.exclusion_reason,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class KeywordCreateDTO:
    """Create DTO for `Keyword`."""

    project_id: str
    keyword: str
    keyword_normalized: str
    seed_topic_id: str | None = None
    topic_id: str | None = None
    parent_keyword_id: str | None = None
    language: str | None = None
    locale: str | None = None
    source: str | None = None
    source_method: str | None = None
    raw_variants: list[str] | None = None
    exclusion_flags: list[str] | None = None
    search_volume: int | None = None
    search_volume_period: str | None = None
    cpc: float | None = None
    competition: float | None = None
    difficulty: float | None = None
    trend_data: list[int] | None = None
    metrics_data_source: str | None = None
    metrics_updated_at: datetime | None = None
    metrics_confidence: float | None = None
    intent: str | None = None
    intent_confidence: float | None = None
    recommended_page_type: str | None = None
    page_type_rationale: str | None = None
    funnel_stage: str | None = None
    risk_flags: list[str] | None = None
    priority_score: float | None = None
    priority_factors: dict | None = None
    serp_top_results: list[dict] | None = None
    serp_features: list[str] | None = None
    validated_intent: str | None = None
    validated_page_type: str | None = None
    format_requirements: list[str] | None = None
    serp_mismatch_flags: list[str] | None = None
    status: str | None = None
    exclusion_reason: str | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "language",
        "locale",
        "source",
        "status",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class KeywordPatchDTO:
    """Sparse patch DTO for `Keyword`."""

    project_id: str | None = None
    seed_topic_id: str | None = None
    topic_id: str | None = None
    parent_keyword_id: str | None = None
    keyword: str | None = None
    keyword_normalized: str | None = None
    language: str | None = None
    locale: str | None = None
    source: str | None = None
    source_method: str | None = None
    raw_variants: list[str] | None = None
    exclusion_flags: list[str] | None = None
    search_volume: int | None = None
    search_volume_period: str | None = None
    cpc: float | None = None
    competition: float | None = None
    difficulty: float | None = None
    trend_data: list[int] | None = None
    metrics_data_source: str | None = None
    metrics_updated_at: datetime | None = None
    metrics_confidence: float | None = None
    intent: str | None = None
    intent_confidence: float | None = None
    recommended_page_type: str | None = None
    page_type_rationale: str | None = None
    funnel_stage: str | None = None
    risk_flags: list[str] | None = None
    priority_score: float | None = None
    priority_factors: dict | None = None
    serp_top_results: list[dict] | None = None
    serp_features: list[str] | None = None
    validated_intent: str | None = None
    validated_page_type: str | None = None
    format_requirements: list[str] | None = None
    serp_mismatch_flags: list[str] | None = None
    status: str | None = None
    exclusion_reason: str | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "KeywordPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class OAuthAccountRow:
    """Read DTO for `OAuthAccount`."""

    user_id: str
    provider: str
    provider_user_id: str
    email: str | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "OAuthAccountRow":
        return cls(
            user_id=model.user_id,
            provider=model.provider,
            provider_user_id=model.provider_user_id,
            email=model.email,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class OAuthAccountCreateDTO:
    """Create DTO for `OAuthAccount`."""

    user_id: str
    provider: str
    provider_user_id: str
    email: str | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class OAuthAccountPatchDTO:
    """Sparse patch DTO for `OAuthAccount`."""

    user_id: str | None = None
    provider: str | None = None
    provider_user_id: str | None = None
    email: str | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "OAuthAccountPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class PipelineRunRow:
    """Read DTO for `PipelineRun`."""

    project_id: str
    started_at: datetime | None
    completed_at: datetime | None
    status: str
    error_message: str | None
    paused_at_step: int | None
    steps_config: dict | None
    start_step: int | None
    end_step: int | None
    skip_steps: list[int] | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "PipelineRunRow":
        return cls(
            project_id=model.project_id,
            started_at=model.started_at,
            completed_at=model.completed_at,
            status=model.status,
            error_message=model.error_message,
            paused_at_step=model.paused_at_step,
            steps_config=model.steps_config,
            start_step=model.start_step,
            end_step=model.end_step,
            skip_steps=model.skip_steps,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class PipelineRunCreateDTO:
    """Create DTO for `PipelineRun`."""

    project_id: str
    started_at: datetime | None = None
    completed_at: datetime | None = None
    status: str | None = None
    error_message: str | None = None
    paused_at_step: int | None = None
    steps_config: dict | None = None
    start_step: int | None = None
    end_step: int | None = None
    skip_steps: list[int] | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "status",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class PipelineRunPatchDTO:
    """Sparse patch DTO for `PipelineRun`."""

    project_id: str | None = None
    started_at: datetime | None = None
    completed_at: datetime | None = None
    status: str | None = None
    error_message: str | None = None
    paused_at_step: int | None = None
    steps_config: dict | None = None
    start_step: int | None = None
    end_step: int | None = None
    skip_steps: list[int] | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "PipelineRunPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class ProjectRow:
    """Read DTO for `Project`."""

    user_id: str
    name: str
    domain: str
    description: str | None
    primary_language: str
    primary_locale: str
    secondary_locales: list[str] | None
    site_maturity: str | None
    maturity_signals: dict | None
    primary_goal: str | None
    secondary_goals: list[str] | None
    primary_cta: str | None
    topic_boundaries: dict | None
    compliance_flags: list[str] | None
    api_budget_caps: dict | None
    caching_ttls: dict | None
    enabled_steps: list[int] | None
    skip_steps: list[int] | None
    current_step: int
    status: str
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "ProjectRow":
        return cls(
            user_id=model.user_id,
            name=model.name,
            domain=model.domain,
            description=model.description,
            primary_language=model.primary_language,
            primary_locale=model.primary_locale,
            secondary_locales=model.secondary_locales,
            site_maturity=model.site_maturity,
            maturity_signals=model.maturity_signals,
            primary_goal=model.primary_goal,
            secondary_goals=model.secondary_goals,
            primary_cta=model.primary_cta,
            topic_boundaries=model.topic_boundaries,
            compliance_flags=model.compliance_flags,
            api_budget_caps=model.api_budget_caps,
            caching_ttls=model.caching_ttls,
            enabled_steps=model.enabled_steps,
            skip_steps=model.skip_steps,
            current_step=model.current_step,
            status=model.status,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class ProjectCreateDTO:
    """Create DTO for `Project`."""

    user_id: str
    name: str
    domain: str
    description: str | None = None
    primary_language: str | None = None
    primary_locale: str | None = None
    secondary_locales: list[str] | None = None
    site_maturity: str | None = None
    maturity_signals: dict | None = None
    primary_goal: str | None = None
    secondary_goals: list[str] | None = None
    primary_cta: str | None = None
    topic_boundaries: dict | None = None
    compliance_flags: list[str] | None = None
    api_budget_caps: dict | None = None
    caching_ttls: dict | None = None
    enabled_steps: list[int] | None = None
    skip_steps: list[int] | None = None
    current_step: int | None = None
    status: str | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "primary_language",
        "primary_locale",
        "current_step",
        "status",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class ProjectPatchDTO:
    """Sparse patch DTO for `Project`."""

    user_id: str | None = None
    name: str | None = None
    domain: str | None = None
    description: str | None = None
    primary_language: str | None = None
    primary_locale: str | None = None
    secondary_locales: list[str] | None = None
    site_maturity: str | None = None
    maturity_signals: dict | None = None
    primary_goal: str | None = None
    secondary_goals: list[str] | None = None
    primary_cta: str | None = None
    topic_boundaries: dict | None = None
    compliance_flags: list[str] | None = None
    api_budget_caps: dict | None = None
    caching_ttls: dict | None = None
    enabled_steps: list[int] | None = None
    skip_steps: list[int] | None = None
    current_step: int | None = None
    status: str | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "ProjectPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class ProjectStyleGuideRow:
    """Read DTO for `ProjectStyleGuide`."""

    project_id: str
    voice_tone_constraints: dict | None
    tone_examples: list[dict] | None
    forbidden_claims: list[str] | None
    compliance_notes: list[str] | None
    legal_disclaimers: list[str] | None
    formatting_requirements: dict | None
    citation_style: str | None
    base_qa_checklist: list[dict] | None
    common_failure_modes: list[str] | None
    default_internal_linking_min: int | None
    default_external_linking_min: int | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "ProjectStyleGuideRow":
        return cls(
            project_id=model.project_id,
            voice_tone_constraints=model.voice_tone_constraints,
            tone_examples=model.tone_examples,
            forbidden_claims=model.forbidden_claims,
            compliance_notes=model.compliance_notes,
            legal_disclaimers=model.legal_disclaimers,
            formatting_requirements=model.formatting_requirements,
            citation_style=model.citation_style,
            base_qa_checklist=model.base_qa_checklist,
            common_failure_modes=model.common_failure_modes,
            default_internal_linking_min=model.default_internal_linking_min,
            default_external_linking_min=model.default_external_linking_min,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class ProjectStyleGuideCreateDTO:
    """Create DTO for `ProjectStyleGuide`."""

    project_id: str
    voice_tone_constraints: dict | None = None
    tone_examples: list[dict] | None = None
    forbidden_claims: list[str] | None = None
    compliance_notes: list[str] | None = None
    legal_disclaimers: list[str] | None = None
    formatting_requirements: dict | None = None
    citation_style: str | None = None
    base_qa_checklist: list[dict] | None = None
    common_failure_modes: list[str] | None = None
    default_internal_linking_min: int | None = None
    default_external_linking_min: int | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class ProjectStyleGuidePatchDTO:
    """Sparse patch DTO for `ProjectStyleGuide`."""

    project_id: str | None = None
    voice_tone_constraints: dict | None = None
    tone_examples: list[dict] | None = None
    forbidden_claims: list[str] | None = None
    compliance_notes: list[str] | None = None
    legal_disclaimers: list[str] | None = None
    formatting_requirements: dict | None = None
    citation_style: str | None = None
    base_qa_checklist: list[dict] | None = None
    common_failure_modes: list[str] | None = None
    default_internal_linking_min: int | None = None
    default_external_linking_min: int | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "ProjectStyleGuidePatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class SeedTopicRow:
    """Read DTO for `SeedTopic`."""

    project_id: str
    name: str
    description: str | None
    pillar_type: str
    icp_relevance: str | None
    product_tie_in: str | None
    intended_content_types: list[str] | None
    coverage_intent: str | None
    relevance_score: float | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "SeedTopicRow":
        return cls(
            project_id=model.project_id,
            name=model.name,
            description=model.description,
            pillar_type=model.pillar_type,
            icp_relevance=model.icp_relevance,
            product_tie_in=model.product_tie_in,
            intended_content_types=model.intended_content_types,
            coverage_intent=model.coverage_intent,
            relevance_score=model.relevance_score,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class SeedTopicCreateDTO:
    """Create DTO for `SeedTopic`."""

    project_id: str
    name: str
    description: str | None = None
    pillar_type: str | None = None
    icp_relevance: str | None = None
    product_tie_in: str | None = None
    intended_content_types: list[str] | None = None
    coverage_intent: str | None = None
    relevance_score: float | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "pillar_type",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class SeedTopicPatchDTO:
    """Sparse patch DTO for `SeedTopic`."""

    project_id: str | None = None
    name: str | None = None
    description: str | None = None
    pillar_type: str | None = None
    icp_relevance: str | None = None
    product_tie_in: str | None = None
    intended_content_types: list[str] | None = None
    coverage_intent: str | None = None
    relevance_score: float | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "SeedTopicPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class StepExecutionRow:
    """Read DTO for `StepExecution`."""

    pipeline_run_id: str
    step_number: int
    step_name: str
    started_at: datetime | None
    completed_at: datetime | None
    status: str
    progress_percent: float
    progress_message: str | None
    items_processed: int
    items_total: int | None
    result_summary: dict | None
    error_message: str | None
    error_traceback: str | None
    checkpoint_data: dict | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "StepExecutionRow":
        return cls(
            pipeline_run_id=model.pipeline_run_id,
            step_number=model.step_number,
            step_name=model.step_name,
            started_at=model.started_at,
            completed_at=model.completed_at,
            status=model.status,
            progress_percent=model.progress_percent,
            progress_message=model.progress_message,
            items_processed=model.items_processed,
            items_total=model.items_total,
            result_summary=model.result_summary,
            error_message=model.error_message,
            error_traceback=model.error_traceback,
            checkpoint_data=model.checkpoint_data,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class StepExecutionCreateDTO:
    """Create DTO for `StepExecution`."""

    pipeline_run_id: str
    step_number: int
    step_name: str
    started_at: datetime | None = None
    completed_at: datetime | None = None
    status: str | None = None
    progress_percent: float | None = None
    progress_message: str | None = None
    items_processed: int | None = None
    items_total: int | None = None
    result_summary: dict | None = None
    error_message: str | None = None
    error_traceback: str | None = None
    checkpoint_data: dict | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "status",
        "progress_percent",
        "items_processed",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class StepExecutionPatchDTO:
    """Sparse patch DTO for `StepExecution`."""

    pipeline_run_id: str | None = None
    step_number: int | None = None
    step_name: str | None = None
    started_at: datetime | None = None
    completed_at: datetime | None = None
    status: str | None = None
    progress_percent: float | None = None
    progress_message: str | None = None
    items_processed: int | None = None
    items_total: int | None = None
    result_summary: dict | None = None
    error_message: str | None = None
    error_traceback: str | None = None
    checkpoint_data: dict | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "StepExecutionPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class TopicRow:
    """Read DTO for `Topic`."""

    project_id: str
    parent_topic_id: str | None
    pillar_seed_topic_id: str | None
    name: str
    description: str | None
    cluster_method: str | None
    cluster_coherence: float | None
    primary_keyword_id: str | None
    dominant_intent: str | None
    dominant_page_type: str | None
    funnel_stage: str | None
    total_volume: int | None
    avg_difficulty: float | None
    keyword_count: int
    estimated_demand: int | None
    priority_rank: int | None
    priority_score: float | None
    priority_factors: dict | None
    recommended_url_type: str | None
    recommended_publish_order: int | None
    target_money_pages: list[str] | None
    expected_role: str | None
    cannibalization_risk: float | None
    overlapping_topic_ids: list[str] | None
    cluster_notes: str | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "TopicRow":
        return cls(
            project_id=model.project_id,
            parent_topic_id=model.parent_topic_id,
            pillar_seed_topic_id=model.pillar_seed_topic_id,
            name=model.name,
            description=model.description,
            cluster_method=model.cluster_method,
            cluster_coherence=model.cluster_coherence,
            primary_keyword_id=model.primary_keyword_id,
            dominant_intent=model.dominant_intent,
            dominant_page_type=model.dominant_page_type,
            funnel_stage=model.funnel_stage,
            total_volume=model.total_volume,
            avg_difficulty=model.avg_difficulty,
            keyword_count=model.keyword_count,
            estimated_demand=model.estimated_demand,
            priority_rank=model.priority_rank,
            priority_score=model.priority_score,
            priority_factors=model.priority_factors,
            recommended_url_type=model.recommended_url_type,
            recommended_publish_order=model.recommended_publish_order,
            target_money_pages=model.target_money_pages,
            expected_role=model.expected_role,
            cannibalization_risk=model.cannibalization_risk,
            overlapping_topic_ids=model.overlapping_topic_ids,
            cluster_notes=model.cluster_notes,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class TopicCreateDTO:
    """Create DTO for `Topic`."""

    project_id: str
    name: str
    parent_topic_id: str | None = None
    pillar_seed_topic_id: str | None = None
    description: str | None = None
    cluster_method: str | None = None
    cluster_coherence: float | None = None
    primary_keyword_id: str | None = None
    dominant_intent: str | None = None
    dominant_page_type: str | None = None
    funnel_stage: str | None = None
    total_volume: int | None = None
    avg_difficulty: float | None = None
    keyword_count: int | None = None
    estimated_demand: int | None = None
    priority_rank: int | None = None
    priority_score: float | None = None
    priority_factors: dict | None = None
    recommended_url_type: str | None = None
    recommended_publish_order: int | None = None
    target_money_pages: list[str] | None = None
    expected_role: str | None = None
    cannibalization_risk: float | None = None
    overlapping_topic_ids: list[str] | None = None
    cluster_notes: str | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "keyword_count",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class TopicPatchDTO:
    """Sparse patch DTO for `Topic`."""

    project_id: str | None = None
    parent_topic_id: str | None = None
    pillar_seed_topic_id: str | None = None
    name: str | None = None
    description: str | None = None
    cluster_method: str | None = None
    cluster_coherence: float | None = None
    primary_keyword_id: str | None = None
    dominant_intent: str | None = None
    dominant_page_type: str | None = None
    funnel_stage: str | None = None
    total_volume: int | None = None
    avg_difficulty: float | None = None
    keyword_count: int | None = None
    estimated_demand: int | None = None
    priority_rank: int | None = None
    priority_score: float | None = None
    priority_factors: dict | None = None
    recommended_url_type: str | None = None
    recommended_publish_order: int | None = None
    target_money_pages: list[str] | None = None
    expected_role: str | None = None
    cannibalization_risk: float | None = None
    overlapping_topic_ids: list[str] | None = None
    cluster_notes: str | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "TopicPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class UserRow:
    """Read DTO for `User`."""

    email: str
    hashed_password: str | None
    full_name: str | None
    is_active: bool
    is_superuser: bool
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "UserRow":
        return cls(
            email=model.email,
            hashed_password=model.hashed_password,
            full_name=model.full_name,
            is_active=model.is_active,
            is_superuser=model.is_superuser,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class UserCreateDTO:
    """Create DTO for `User`."""

    email: str
    hashed_password: str | None = None
    full_name: str | None = None
    is_active: bool | None = None
    is_superuser: bool | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = {
        "is_active",
        "is_superuser",
    }

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class UserPatchDTO:
    """Sparse patch DTO for `User`."""

    email: str | None = None
    hashed_password: str | None = None
    full_name: str | None = None
    is_active: bool | None = None
    is_superuser: bool | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "UserPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

@dataclass(slots=True)
class WriterInstructionsRow:
    """Read DTO for `WriterInstructions`."""

    brief_id: str
    voice_tone_constraints: dict | None
    forbidden_claims: list[str] | None
    compliance_notes: list[str] | None
    formatting_requirements: dict | None
    h1_h2_usage: dict | None
    internal_linking_minimums: dict | None
    schema_guidance: str | None
    snippet_ctr_guidelines: str | None
    qa_checklist: list[dict] | None
    pass_fail_thresholds: dict | None
    common_failure_modes: list[dict] | None
    link_placeholders: dict | None
    schema_block_templates: dict | None
    citation_templates: dict | None
    id: str
    created_at: datetime
    updated_at: datetime

    @classmethod
    def from_model(cls, model: Any) -> "WriterInstructionsRow":
        return cls(
            brief_id=model.brief_id,
            voice_tone_constraints=model.voice_tone_constraints,
            forbidden_claims=model.forbidden_claims,
            compliance_notes=model.compliance_notes,
            formatting_requirements=model.formatting_requirements,
            h1_h2_usage=model.h1_h2_usage,
            internal_linking_minimums=model.internal_linking_minimums,
            schema_guidance=model.schema_guidance,
            snippet_ctr_guidelines=model.snippet_ctr_guidelines,
            qa_checklist=model.qa_checklist,
            pass_fail_thresholds=model.pass_fail_thresholds,
            common_failure_modes=model.common_failure_modes,
            link_placeholders=model.link_placeholders,
            schema_block_templates=model.schema_block_templates,
            citation_templates=model.citation_templates,
            id=model.id,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

@dataclass(slots=True)
class WriterInstructionsCreateDTO:
    """Create DTO for `WriterInstructions`."""

    brief_id: str
    voice_tone_constraints: dict | None = None
    forbidden_claims: list[str] | None = None
    compliance_notes: list[str] | None = None
    formatting_requirements: dict | None = None
    h1_h2_usage: dict | None = None
    internal_linking_minimums: dict | None = None
    schema_guidance: str | None = None
    snippet_ctr_guidelines: str | None = None
    qa_checklist: list[dict] | None = None
    pass_fail_thresholds: dict | None = None
    common_failure_modes: list[dict] | None = None
    link_placeholders: dict | None = None
    schema_block_templates: dict | None = None
    citation_templates: dict | None = None

    _DROP_NONE_FIELDS: ClassVar[set[str]] = set()

    def to_orm_kwargs(self) -> dict[str, Any]:
        payload = asdict(self)
        for key in self._DROP_NONE_FIELDS:
            if payload.get(key) is None:
                payload.pop(key, None)
        return payload

@dataclass(slots=True)
class WriterInstructionsPatchDTO:
    """Sparse patch DTO for `WriterInstructions`."""

    brief_id: str | None = None
    voice_tone_constraints: dict | None = None
    forbidden_claims: list[str] | None = None
    compliance_notes: list[str] | None = None
    formatting_requirements: dict | None = None
    h1_h2_usage: dict | None = None
    internal_linking_minimums: dict | None = None
    schema_guidance: str | None = None
    snippet_ctr_guidelines: str | None = None
    qa_checklist: list[dict] | None = None
    pass_fail_thresholds: dict | None = None
    common_failure_modes: list[dict] | None = None
    link_placeholders: dict | None = None
    schema_block_templates: dict | None = None
    citation_templates: dict | None = None
    _provided_fields: set[str] = field(
        default_factory=set,
        repr=False,
        compare=False,
    )

    @classmethod
    def from_partial(cls, payload: dict[str, Any]) -> "WriterInstructionsPatchDTO":
        obj = cls(**payload)
        obj._provided_fields = set(payload.keys())
        return obj

    def to_patch_dict(self) -> dict[str, Any]:
        payload = asdict(self)
        payload.pop("_provided_fields", None)
        return {
            key: value
            for key, value in payload.items()
            if key in self._provided_fields
        }

__all__ = [
    "BrandProfileRow",
    "BrandProfileCreateDTO",
    "BrandProfilePatchDTO",
    "BriefDeltaRow",
    "BriefDeltaCreateDTO",
    "BriefDeltaPatchDTO",
    "ContentArticleRow",
    "ContentArticleCreateDTO",
    "ContentArticlePatchDTO",
    "ContentArticleVersionRow",
    "ContentArticleVersionCreateDTO",
    "ContentArticleVersionPatchDTO",
    "ContentBriefRow",
    "ContentBriefCreateDTO",
    "ContentBriefPatchDTO",
    "DiscoveryTopicSnapshotRow",
    "DiscoveryTopicSnapshotCreateDTO",
    "DiscoveryTopicSnapshotPatchDTO",
    "KeywordRow",
    "KeywordCreateDTO",
    "KeywordPatchDTO",
    "OAuthAccountRow",
    "OAuthAccountCreateDTO",
    "OAuthAccountPatchDTO",
    "PipelineRunRow",
    "PipelineRunCreateDTO",
    "PipelineRunPatchDTO",
    "ProjectRow",
    "ProjectCreateDTO",
    "ProjectPatchDTO",
    "ProjectStyleGuideRow",
    "ProjectStyleGuideCreateDTO",
    "ProjectStyleGuidePatchDTO",
    "SeedTopicRow",
    "SeedTopicCreateDTO",
    "SeedTopicPatchDTO",
    "StepExecutionRow",
    "StepExecutionCreateDTO",
    "StepExecutionPatchDTO",
    "TopicRow",
    "TopicCreateDTO",
    "TopicPatchDTO",
    "UserRow",
    "UserCreateDTO",
    "UserPatchDTO",
    "WriterInstructionsRow",
    "WriterInstructionsCreateDTO",
    "WriterInstructionsPatchDTO",
]
